
# 操作系统实验报告

## 实验内容

本次实验主要完成以下内容:
- 熟悉RISC-V架构和QEMU模拟器的使用
- 实现基本的内核启动流程
- 实现内存管理功能（物理内存管理和页表分配）
- 实现进程调度和上下文切换
- 实现系统调用和中断处理

## 物理内存管理与页表分配分析

物理内存管理本质上是一个页帧管理器，它采用链表结构管理可用的物理页。在系统初始化阶段，通过pmem_init函数进行初始化。它将所有的物理内存划分为内核区域和用户区域两部分：

内核区域被划分在0x80000000地址开始的一段连续内存中，通过一个链表结构组织，链表中的每个节点代表一个物理页（每页4096字节）。用户区域则使用剩余的物理内存。通过pmem_alloc函数分配物理页，具体是通过从空闲链表头部取下一个节点，将该页分配给请求者。而pmem_free函数则回收物理页，将物理页重新插入空闲链表的头部。为了保证多线程安全，这些操作都使用了自旋锁机制。

页表分配机制基于RISC-V架构的SV39分页机制。页表是三级结构，分别对应不同的地址层次。VM初始化过程中，kernel_pgtbl建立了一个内核页表，其中包含了硬件寄存器区域的映射（如UART、PLIC、CLINT等）和可用内存的恒等映射（0x80000000~0x88000000）。而vm_getpte函数实现了页表项的获取功能。当在访问虚拟地址时，它会通过三级页表结构寻找最终的页表项，如果某一级页表项无效且允许分配就自动分配新的页表并建立映射关系。vm_mappages函数用于将虚拟地址映射到物理地址，每次映射一个页大小的空间，通过修改页表项完成映射关系的建立。虚拟地址和物理地址的转换通过宏定义完成。

通过这些机制，系统实现了物理内存的动态分配和管理，同时也实现了虚拟地址到物理地址的映射关系。当进程需要使用内存时，可以根据需要分配物理页并通过页表建立虚拟地址到物理地址的映射，从而完成内存的管理。页表管理处于系统内核核心层，内存管理策略保证了任务之间的内存隔离和系统内存的安全利用。

## trapframe与context的区别

trapframe和context是操作系统中两个不同用途的结构体，它们的主要区别如下：

trapframe结构体用于保存中断或异常发生时的处理器状态。它包含了在用户态和内核态切换时需要保存的所有寄存器值，包括：
- 内核相关字段：kernel_satp(内核页表地址)、kernel_sp(进程内核栈)、kernel_trap(用户陷阱处理函数)、epc(保存的用户程序计数器)、kernel_hartid(保存的内核线程ID)
- 寄存器状态：ra, sp, gp, tp, t0-t6, s0-s11, a0-a7等通用寄存器

trapframe主要在以下场景使用：
- 用户程序发生异常或中断时，保存当前寄存器状态
- 异常处理完成后，恢复用户程序的执行环境
- 系统调用过程中保存和恢复进程状态

context结构体用于保存进程在内核态的执行上下文。它主要包含：
- ra(返回地址)
- sp(栈指针)
- s0-s11(被调用者保存的寄存器)

context主要用于进程切换时保存和恢复进程的内核态执行状态，确保进程能够在被抢占后正确恢复执行。

简单来说，trapframe关注的是用户态和内核态切换时寄存器的整体状态保存，而context则专注于内核态进程切换时的关键寄存器保存。

## 1.1 架构设计说明

### 用户态与内核态的分离
系统实现了完整的用户态和内核态分离机制。在RISC-V架构中，用户态运行在S-mode模式下，而内核态运行在M-mode模式下。系统通过特权级保护来实现安全的内存访问和系统资源管理。

### 进程管理架构
系统采用多进程设计，支持进程的创建、调度和销毁。进程结构体(proc_t)包含了进程的完整状态信息，包括：
- pid：进程标识符
- pgtbl：用户态页表，用于进行地址空间隔离
- heap_top：用户堆顶指针，跟踪用户进程的堆内存使用情况
- ustack_pages：用户栈占用的页面数量
- tf：trapframe指针，用于保存用户态到内核态切换时的运行环境
- kstack：内核栈的虚拟地址
- ctx：context结构体，保存内核态进程上下文

### 内存隔离机制
通过页表机制实现用户态与内核态的内存隔离，每个进程都有独立的用户态页表，保证进程间内存访问的相互隔离。

### 文件系统缓冲区机制(buf)
系统实现了基于buf结构体的磁盘块缓存机制，用于提高文件系统的I/O性能：

buf结构体是文件系统的核心缓存组件，具有以下特点：
- 通过block_num字段标识对应的磁盘块编号
- 通过data数组存储该磁盘块的数据内容
- 通过buf_ref计数器跟踪有多少处引用了这个缓存块
- 通过disk标志位标识该buf是否正在被磁盘驱动使用
- 通过slk自旋锁保护对缓冲区的并发访问

提供的核心功能包括：
- buf_read：根据块编号从磁盘读取数据到缓存
- buf_write：将缓存中的数据写回磁盘
- buf_release：释放对缓存块的引用
- buf_init：初始化缓冲区系统
- buf_print：打印缓冲区的状态信息

缓冲区管理的优势包括：
- 提高磁盘I/O性能：避免频繁的磁盘访问
- 提供数据一致性：多个进程或模块可以共享相同的缓冲区内容
- 避免重复读取：相同的数据块只读取一次到内存
- 引用计数机制：避免在使用中的缓存被过早释放
- 线程安全：使用自旋锁保护缓冲区的并发访问

[1]().2 **关键数据结构**

**1.3 与xv6对比**

1.4 设计决策理由
